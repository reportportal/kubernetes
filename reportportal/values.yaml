## ReportPortal.io AI-powered Test Automation Dashboard
##

## @section Global configuration
##
global:
  ## @param global.imageRegistry Global image registry
  ##
  imageRegistry: ""
  ## @param global.imagePullSecrets Global registry secret names as an array
  ##
  imagePullSecrets: []
  ## @param global.nameOverride expand the name of the chart
  ##
  nameOverride: ""
  ## @param global.fullnameOverride expand the fully qualified app name
  ##
  fullnameOverride: ""
  security:
    allowInsecureImages: true
  serviceAccount:
    create: true
    name: reportportal
    ## @param serviceAccount.annotations For AWS IAM role association use the following annotations
    ## See: https://docs.aws.amazon.com/eks/latest/userguide/specify-service-account-role.html
    ##
    annotations: {}
  ## @param global.argocd.enabled Enable ArgoCD webhooks for ServiceAccount, Role, RoleBinding, and pre-upgrade cleanup
  ## Set to true when deploying with ArgoCD to ensure proper resource ordering
  ##
  argocd:
    enabled: false
  ## @param global.securityContext Default security context for all pods
  ##
  securityContext: {}
  ## @param global.tolerations Global tolerations for all components (overrides service-specific tolerations)
  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  ##
  tolerations: []
    # - key: "key"
    #   operator: "Equal|Exists"
    #   value: "value"
    #   effect: "NoSchedule|PreferNoSchedule|NoExecute"
  ## @param global.pdb Global pod disruption budgets for all components (overrides service-specific pdb)
  ## Ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
  ##
  pdb:
    ## @param global.pdb.create Enable/disable a Pod Disruption Budget creation
    ##
    create: true
    ## @param global.pdb.minAvailable Minimum number/percentage of pods that should remain scheduled
    ##
    minAvailable: ""
    ## @param global.pdb.maxUnavailable Maximum number/percentage of pods that may be made unavailable. Defaults to `1` if both `global.pdb.minAvailable` and `global.pdb.maxUnavailable` are empty.
    ##
    maxUnavailable: "1"


## @param serviceindex Core ReportPortal service for the indexing
##
serviceindex:
  name: index
  image:
    repository: reportportal/service-index
    tag: 5.15.0
  pullPolicy: Always
  resources:
    requests:
      cpu: 150m
      memory: 128Mi
    limits:
      cpu: 200m
      memory: 256Mi

  ## @param serviceindex.extraInitContainers init containers
  ##
  extraInitContainers: {}
    # - name: init-container
    #   image: busybox
    #   command: ['sh', '-c', 'echo "Hello, World!"']
    #   resources:
    #     requests:
    #       cpu: 10m
    #       memory: 10Mi
    #     limits:
    #       cpu: 100m
    #       memory: 100Mi
  podLabels: {}
  podAnnotations: {}
  securityContext: {}
  serviceAccountName: ""
  ## @param serviceindex.readinessProbe configure readiness probe
  ##
  readinessProbe:
    enabled: true
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
  ## @param serviceindex.livenessProbe configure liveness probe
  ##
  livenessProbe:
    enabled: true
    initialDelaySeconds: 60
    periodSeconds: 30
    timeoutSeconds: 5
    failureThreshold: 3
  ## @param serviceindex.nodeSelector define which Nodes the Pods are scheduled on.
  ## You can choose compute classes for GKE Autopilot Pods https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-compute-classes
  ## Use cloud.google.com/compute-class: "COMPUTE_CLASS" for specific GKE Autopilot compute class.
  ## Use kubernetes.io/arch: "ARCHITECTURE" for specific GKE Autopilot CPU architecture.
  ## Use disktype: "ssd" for specific disk type.
  ##
  nodeSelector: {}
  affinity: {}
  ## @param serviceindex.tolerations Service-specific tolerations for the index service
  tolerations: []
  ## @param serviceindex.strategy Deployment strategy for the index service
  ## Ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
  ##
  strategy: {}
    # type: RollingUpdate
    # rollingUpdate:
    #   maxSurge: 1
    #   maxUnavailable: 0
  ## @param serviceindex.pdb Service-specific pod disruption budget for the index service
  pdb:
    create: false
    minAvailable: ""
    maxUnavailable: ""
  service:
    type: ""
    portName: ""
    nodePort: ""
    extraPorts: []
    annotations: {}
    ## @param serviceindex.service.labels Custom labels for the Service (e.g., for Prometheus ServiceMonitor)
    ##
    labels: {}

## @param serviceui Core ReportPortal service
##
serviceui:
  name: ui
  image:
    repository: reportportal/service-ui
    tag: 5.15.0
  pullPolicy: Always
  replicaCount: 1
  resources:
    requests:
      cpu: 100m
      memory: 64Mi
    limits:
      cpu: 200m
      memory: 128Mi

  ## @param serviceui.extraInitContainers init containers
  ##
  extraInitContainers: {}

  ## @param serviceui.extraVolumes define the extra volumes
  ##
  extraVolumes: []
    # - name: extra-volume
    #   emptyDir: {}
  ## @param serviceui.extraVolumeMounts define the extra volume mounts
  ##
  extraVolumeMounts: []
    # - name: extra-volume
    #   mountPath: /path/to/mount
    #   readOnly: true
  podLabels: {}
  affinity: {}
  podAnnotations: {}
  securityContext: {}
  ## @param serviceui.readinessProbe configure readiness probe
  ##
  readinessProbe:
    enabled: true
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
  ## @param serviceui.livenessProbe configure liveness probe
  ##
  livenessProbe:
    enabled: true
    initialDelaySeconds: 60
    periodSeconds: 30
    timeoutSeconds: 5
    failureThreshold: 3
  ## @param serviceui.nodeSelector define which Nodes the Pods are scheduled on.
  ## You can choose compute classes for GKE Autopilot Pods https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-compute-classes
  ## Use cloud.google.com/compute-class: "COMPUTE_CLASS" for specific GKE Autopilot compute class.
  ## Use kubernetes.io/arch: "ARCHITECTURE" for specific GKE Autopilot CPU architecture.
  ##
  nodeSelector: {}
  serviceAccountName: ""
  ## @param serviceui.tolerations Service-specific tolerations for the UI service
  tolerations: []
  ## @param serviceui.strategy Deployment strategy for the UI service
  ## Ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
  ##
  strategy: {}
    # type: RollingUpdate
    # rollingUpdate:
    #   maxSurge: 1
    #   maxUnavailable: 0
  ## @param serviceui.pdb Service-specific pod disruption budget for the UI service
  pdb:
    create: false
    minAvailable: ""
    maxUnavailable: ""
  service:
    type: ""
    portName: ""
    nodePort: ""
    extraPorts: []
    annotations: {}
    ## @param serviceui.service.labels Custom labels for the Service (e.g., for Prometheus ServiceMonitor)
    ##
    labels: {}

## @param serviceapi Core ReportPortal
##
serviceapi:
  name: api
  image:
    repository: reportportal/service-api
    tag: 5.15.0
  pullPolicy: Always
  replicaCount: 1
  readinessProbe:
    enabled: true
    initialDelaySeconds: 40
    periodSeconds: 20
    timeoutSeconds: 5
    failureThreshold: 20
  livenessProbe:
    enabled: true
    initialDelaySeconds: 40
    periodSeconds: 20
    timeoutSeconds: 5
    failureThreshold: 10
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
    limits:
      cpu: 1000m
      memory: 2Gi
  ## @param serviceapi.extraInitContainers init containers
  ##
  extraInitContainers: {}
  ## @param serviceapi.extraVolumes define the extra volumes
  ##
  extraVolumes: []
  ## @param serviceapi.extraVolumeMounts define the extra volume mounts
  ##
  extraVolumeMounts: []
  ## @param serviceapi.auditLogs define audit logging configuration
  ## @param serviceapi.auditLogs.enable Enable audit logging (sets AUDIT_LOGGER env var and mounts log volume)
  ## @param serviceapi.auditLogs.loglevel Audit log level
  ##
  ## WARNING: Enabling audit logs writes to an emptyDir volume on the node.
  ## Monitor node storage usage to prevent disk pressure issues.
  ## Consider using a log collector (e.g., fluentbit) to ship logs externally.
  ##
  ## For custom log collectors, set auditLogs.sidecar.enable=false and configure
  ## your collector via extraInitContainers, extraVolumes, and extraVolumeMounts.
  ##
  auditLogs:
    enable: false
    loglevel: info
    ## @param serviceapi.auditLogs.sidecar Default sidecar container for streaming audit logs to stdout
    ## Set sidecar.enable=true to use the built-in log streamer (streams to container stdout)
    ## For custom log collectors (e.g., fluentbit), set sidecar.enable=false
    ##
    sidecar:
      ## @param serviceapi.auditLogs.sidecar.enable Enable the default audit log streamer sidecar
      ##
      enable: false
      image:
        repository: busybox
        tag: latest
      resources:
        requests:
          cpu: 10m
          memory: 10Mi
        limits:
          cpu: 100m
          memory: 100Mi
  ## @param serviceapi.allowDeleteAccount enable or disable "Delete Account" button in UI
  ##
  allowDeleteAccount: true
  ## @param serviceapi.cronJobs define the configuration for the cron jobs
  ##
  cronJobs:
    ## @param serviceapi.cronJobs.interruptBrockenLaunches define the duration for the cron job to interrupt broken launches
    ## ISO8601 duration format
    ##
    interruptBrockenLaunches: PT1H
    ## @param serviceapi.cronJobs.loadPlugins define the duration for the cron job to load plugins
    ## ISO8601 duration format
    ##
    loadPlugins: PT10S
  ## @param serviceapi.patternAnalysis define the configuration for the pattern analysis and Immediate IA
  ## @paran serviceapi.patternAnalysis.batchSize define the number of logs to be processed in one batch
  ## @param serviceapi.patternAnalysis.prefetchCount define of the prefetch count for 'analysis.pattern.string' and 'analysis.pattern.regex' queues.
  ## @param serviceapi.patternAnalysis.consumersCount define of the 'analysis.pattern.string' and 'analysis.pattern.regex' queues. Consumers count per each queue
  ##
  patternAnalysis:
    batchSize: 100
    prefetchCount: 1
    consumersCount: 1
  ## @param serviceapi.javaArgs define the configuration for the JVM.
  ## For custom java keystore add parameter: -Djavax.net.ssl.trustStore=/etc/secret-volume/custom-pki.jks
  ##
  jvmArgs: "-Djava.security.egd=file:/dev/./urandom -XX:+UseG1GC -XX:MinRAMPercentage=60.0 -XX:InitiatingHeapOccupancyPercent=70 -XX:MaxRAMPercentage=90.0 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp"
  ## @param serviceapi.amqp define the configuration for the AMQP
  ##
  amqp:
    ## @param serviceapi.amqp.queues define the number for the queues
    ##
    queues: 10
    ## @param serviceapi.amqp.prefetchCount define the prefetch count per consumer
    ##
    prefetchCount: 10
    ## @param serviceapi.amqp.consumersCount define time to live in parking lot queue
    ##
    parkingLotTtlDays: 7
  ## @param serviceapi.extraEnvs define the extra environment variables
  ##
  extraEnvs: []
    # - name: EXTRA_ENV
    #   value: "TRUE"
    # - name: EXTRA_ENV_SECRET
    #   valueFrom:
    #     secretKeyRef:
    #       name: "additional-credentials"
    #       key: username
  affinity: {}
  podLabels: {}
  podAnnotations: {}
  securityContext: {}
  ## @param serviceapi.nodeSelector define which Nodes the Pods are scheduled on.
  ## You can choose compute classes for GKE Autopilot Pods https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-compute-classes
  ## Use cloud.google.com/compute-class: COMPUTE_CLASS for specific GKE Autopilot compute class.
  ## Use kubernetes.io/arch: ARCHITECTURE for specific GKE Autopilot CPU architecture.
  ##
  nodeSelector: {}
  serviceAccountName: ""
  ## @param serviceapi.tolerations Service-specific tolerations for the API service
  tolerations: []
  ## @param serviceapi.strategy Deployment strategy for the API service
  ## Ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
  ##
  strategy: {}
    # type: RollingUpdate
    # rollingUpdate:
    #   maxSurge: 1
    #   maxUnavailable: 0
  ## @param serviceapi.pdb Service-specific pod disruption budget for the API service
  pdb:
    create: false
    minAvailable: ""
    maxUnavailable: ""
  service:
    type: ""
    portName: ""
    nodePort: ""
    extraPorts: []
    annotations: {}
    ## @param serviceapi.service.labels Custom labels for the Service (e.g., for Prometheus ServiceMonitor)
    ##
    labels: {}
  ## @param serviceapi.secret define the secret configuration
  ## e.g. provide a custom java keystore used in jvmArgs:
  ## keytool -genkeypair -storetype jks -alias todelete -keypass changeit -storepass changeit -keystore custom-pki.jks -dname "CN=Developer, OU=Department, O=Company, L=City, ST=State, C=CA"
  ## keytool -delete -alias todelete -storepass changeit -keystore custom-pki.jks
  ## keytool -list -keystore custom-pki.jks -storepass changeit
  ## Generate base64 data and paste it in your values.yaml:
  ## cat custom-pki.jks | base64 -w
  ##
  secret:
    enabled: false
    mountPath: /etc/secret-volume
    readOnly: true
    data: {}
    #  custom-pki.jks: <base64-data>
  ## @param serviceapi.hostAliases define the hosts and IP addresses for the Pod's /etc/hosts file.
  ##
  hostAliases: []
    # - ip: "127.0.0.1"
    #   hostnames:
    #     - "foo.local"
    #     - "bar.local"
    # - ip: "10.1.2.3"
    #   hostnames:
    #     - "foo.remote"
    #     - "bar.remote"

## @param serviceapi Core ReportPortal service for the authorization
##
uat:
  name: uat
  image:
    repository: reportportal/service-authorization
    tag: 5.15.0
  pullPolicy: Always
  replicaCount: 1
  readinessProbe:
    enabled: true
    initialDelaySeconds: 60
    periodSeconds: 40
    timeoutSeconds: 5
    failureThreshold: 10
  livenessProbe:
    enabled: true
    initialDelaySeconds: 60
    periodSeconds: 40
    timeoutSeconds: 5
    failureThreshold: 10
  resources:
    requests:
      cpu: 100m
      memory: 512Mi
    limits:
      cpu: 500m
      memory: 1Gi
  sessionLiveTime: 86400
  samlSessionLiveTime: 4320
  ## @param uat.extraInitContainers init containers
  ##
  extraInitContainers: {}
  ## @param uat.extraVolumes define the extra volumes
  ##
  extraVolumes: []
  ## @param uat.extraVolumeMounts define the extra volume mounts
  ##
  extraVolumeMounts: []
  ## @param uat.superadminInitPasswd define the initial password of the superadmin user for the first launch. This value can't change the password on redeployments
  ## @param uat.superadminInitPasswd.secretName define the secret name for the superadmin password
  ##
  superadminInitPasswd:
    secretName: ""
    passwordKeyName: "superadmin-password"
    password: ""
  ## @param uat.javaArgs define the configuration for the JVM.
  ## For custom java keystore add parameter: -Djavax.net.ssl.trustStore=/etc/secret-volume/custom-pki.jks
  ##
  jvmArgs: "-Djava.security.egd=file:/dev/./urandom -XX:MinRAMPercentage=60.0 -XX:MaxRAMPercentage=90.0 --add-opens=java.base/java.lang=ALL-UNNAMED"
  ## @param uat.extraEnvs define the extra environment variables
  ##
  extraEnvs: []
    # - name: EXTRA_ENV
    #   value: "TRUE"
    # - name: EXTRA_ENV_SECRET
    #   valueFrom:
    #     secretKeyRef:
    #       name: "additional-credentials"
    #       key: username
  podLabels: {}
  podAnnotations: {}
  securityContext: {}
  ## @param uat.nodeSelector define which Nodes the Pods are scheduled on
  ## You can choose compute classes for GKE Autopilot Pods https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-compute-classes
  ## Use cloud.google.com/compute-class: "COMPUTE_CLASS" for specific GKE Autopilot compute class.
  ## Use kubernetes.io/arch: "ARCHITECTURE" for specific GKE Autopilot CPU architecture.
  ##
  nodeSelector: {}
  affinity: {}
  serviceAccountName: ""
  ## @param uat.tolerations Service-specific tolerations for the authorization service
  tolerations: []
  ## @param uat.strategy Deployment strategy for the authorization service
  ## Ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
  ##
  strategy: {}
    # type: RollingUpdate
    # rollingUpdate:
    #   maxSurge: 1
    #   maxUnavailable: 0
  ## @param uat.pdb Service-specific pod disruption budget for the authorization service
  pdb:
    create: false
    minAvailable: ""
    maxUnavailable: ""
  ## @param uat.secret define the secret configuration
  ## e.g. provide a custom java keystore used in jvmArgs:
  ## keytool -genkeypair -storetype jks -alias todelete -keypass changeit -storepass changeit -keystore custom-pki.jks -dname "CN=Developer, OU=Department, O=Company, L=City, ST=State, C=CA"
  ## keytool -delete -alias todelete -storepass changeit -keystore custom-pki.jks
  ## keytool -list -keystore custom-pki.jks -storepass changeit
  ## Generate base64 data and paste it in your values.yaml:
  ## cat custom-pki.jks | base64 -w
  ##
  secret:
    enabled: false
    mountPath: /etc/secret-volume
    readOnly: true
    data: {}
      # custom-pki.jks: <base64-data>
  service:
    type: ""
    portName: ""
    nodePort: ""
    extraPorts: []
    annotations: {}
    ## @param uat.service.labels Custom labels for the Service (e.g., for Prometheus ServiceMonitor)
    ##
    labels: {}
  ## @param uat.hostAliases define the hosts and IP addresses for the Pod's /etc/hosts file.
  ##
  hostAliases: []
    # - ip: "127.0.0.1"
    #   hostnames:
    #     - "foo.local"
    #     - "bar.local"
    # - ip: "10.1.2.3"
    #   hostnames:
    #     - "foo.remote"
    #     - "bar.remote"

## @param serviceapi Core ReportPortal service for the CRON jobs to clean the database and storage
##
servicejobs:
  name: jobs
  image:
    repository: reportportal/service-jobs
    tag: 5.15.0
  pullPolicy: Always
  readinessProbe:
    enabled: true
    initialDelaySeconds: 60
    periodSeconds: 40
    timeoutSeconds: 5
    failureThreshold: 10
  livenessProbe:
    enabled: true
    initialDelaySeconds: 60
    periodSeconds: 40
    timeoutSeconds: 5
    failureThreshold: 10
  ## @param servicejobs.coreJobs define the configuration for the core jobs that clean the database and storage
  ## @param servicejobs.coreJobs.cleanEventsRetention define the number of days to keep events in the database
  ## @param servicejobs.coreJobs.cleanEventsCron define the cron expression for the clean events job
  ## @param servicejobs.coreJobs.cleanAttachmentCron define the cron expression for the clean attachments job from database
  ## @param servicejobs.coreJobs.cleanLogCron define the cron expression for the clean logs job
  ## @param servicejobs.coreJobs.cleanLaunchCron define the cron expression for the clean launches job
  ## @param servicejobs.coreJobs.batchSize define the number of launches to be processed in one batch
  ## @param servicejobs.coreJobs.cleanStorageCron define the cron expression for the clean storage job the binary storage
  ## @param servicejobs.coreJobs.storageProjectCron define the cron expression for the calculating average project attachments storage job
  ## @param servicejobs.chunksize define the number of binaries to be removed from binary storage by servicejobs.storageProjectCron within one job execution
  ##
  coreJobs:
    cleanEventsRetention: 365
    cleanEventsCron: 0 0 */24 * * *
    cleanAttachmentCron: 0 0 */24 * * *
    cleanLogCron: 0 0 */24 * * *
    cleanLaunchCron: 0 0 */24 * * *
    batchSize: 10000
    cleanStorageCron: 0 0 */24 * * *
    storageProjectCron: 0 */5 * * * *
  ## @param servicejobs.chunksize define the number of binaries to be removed from binary storage by servicejobs.storageProjectCron within one job execution
  chunksize: 200000
  ## @param.servicejobs.resources define the resources for the service jobs
  resources:
    requests:
      cpu: 100m
      memory: 248Mi
    limits:
      cpu: 250m
      memory: 512Mi
  ## @param servicjobs.extraInitContainers init containers
  ##
  extraInitContainers: {}
  ## @param uat.extraVolumes define the extra volumes
  ##
  extraVolumes: []
  ## @param servicjobs.extraVolumeMounts define the extra volume mounts
  ##
  extraVolumeMounts: []
  ## @param servicjobs.javaArgs define the configuration for the JVM.
  ## For custom java keystore add parameter: -Djavax.net.ssl.trustStore=/etc/secret-volume/custom-pki.jks
  ##
  jvmArgs: "-Djava.security.egd=file:/dev/./urandom -XX:+UseG1GC -XX:+UseStringDeduplication -XX:G1ReservePercent=20 -XX:InitiatingHeapOccupancyPercent=60 -XX:MaxRAMPercentage=70.0 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp"
  ## @param servicejobs.extraEnvs define the extra environment variables
  ##
  extraEnvs: []
    # - name: EXTRA_ENV
    #   value: "TRUE"
    # - name: EXTRA_ENV_SECRET
    #   valueFrom:
    #     secretKeyRef:
    #       name: "additional-credentials"
    #       key: username
  podLabels: {}
  podAnnotations: {}
  securityContext: {}
  ## @param servicejobs.nodeSelector define which Nodes the Pods are scheduled on.
  ## You can choose compute classes for GKE Autopilot Pods https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-compute-classes
  ## Use cloud.google.com/compute-class: COMPUTE_CLASS for specific GKE Autopilot compute class.
  ## Use kubernetes.io/arch: ARCHITECTURE for specific GKE Autopilot CPU architecture.
  ##
  nodeSelector: {}
  affinity: {}
  serviceAccountName: ""
  ## @param servicejobs.tolerations Service-specific tolerations for the jobs service
  tolerations: []
  ## @param servicejobs.strategy Deployment strategy for the jobs service
  ## Ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
  ##
  strategy: {}
    # type: RollingUpdate
    # rollingUpdate:
    #   maxSurge: 1
    #   maxUnavailable: 0
  ## @param servicejobs.pdb Service-specific pod disruption budget for the jobs service
  pdb:
    create: false
    minAvailable: ""
    maxUnavailable: ""
  service:
    type: ""
    portName: ""
    nodePort: ""
    extraPorts: []
    annotations: {}
    ## @param servicejobs.service.labels Custom labels for the Service (e.g., for Prometheus ServiceMonitor)
    ##
    labels: {}

## @param serviceanalyzer Core ReportPortal service for the analysis of test results
##
serviceanalyzer:
  name: analyzer
  image:
    repository: reportportal/service-auto-analyzer
    tag: 5.15.0
  pullPolicy: Always
  uwsgiWorkers: 2
  resources:
    requests:
      cpu: 500m
      memory: 512Mi
    limits:
      cpu: 500m
      memory: 1Gi
  ## @param serviceanalyzer.extraInitContainers init containers
  ##
  extraInitContainers: {}
  ## @param uat.extraVolumes define the extra volumes
  ##
  extraVolumes: []
  ## @param serviceanalyzer.extraVolumeMounts define the extra volume mounts
  ##
  extraVolumeMounts: []
  podLabels: {}
  podAnnotations: {}
  securityContext: {}
  ## @param serviceanalyzer.extraEnvs define the extra environment variables
  ##
  extraEnvs: []
    # - name: EXTRA_ENV
    #   value: "TRUE"
    # - name: EXTRA_ENV_SECRET
    #   valueFrom:
    #     secretKeyRef:
    #       name: "additional-credentials"
    #       key: username
  ## @param serviceanalyzer.nodeSelector define which Nodes the Pods are scheduled on.
  ## You can choose compute classes for GKE Autopilot Pods https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-compute-classes
  ## Use cloud.google.com/compute-class: "COMPUTE_CLASS" for specific GKE Autopilot compute class.
  ## Use kubernetes.io/arch: "ARCHITECTURE" for specific GKE Autopilot CPU architecture.
  ##
  nodeSelector: {}
  affinity: {}
  serviceAccountName: ""
  ## @param serviceanalyzer.tolerations Service-specific tolerations for the analyzer service
  tolerations: []
  ## @param serviceanalyzer.updateStrategy Update strategy for the analyzer StatefulSet
  ## Ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
  ##
  updateStrategy: {}
    # type: RollingUpdate
    # rollingUpdate:
    #   partition: 0
  ## @param serviceanalyzer.pdb Service-specific pod disruption budget for the analyzer service
  pdb:
    create: false
    minAvailable: ""
    maxUnavailable: ""
  service:
    type: ""
    portName: ""
    nodePort: ""
    extraPorts: []
    annotations: {}
    ## @param serviceanalyzer.service.labels Custom labels for the Service (e.g., for Prometheus ServiceMonitor)
    ##
    labels: {}
  ## @param serviceanalyzer.readinessProbe configure readiness probe
  ##
  readinessProbe:
    enabled: true
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
  ## @param serviceanalyzer.livenessProbe configure liveness probe
  ##
  livenessProbe:
    enabled: true
    initialDelaySeconds: 60
    periodSeconds: 30
    timeoutSeconds: 10
    failureThreshold: 3
    successThreshold: 1

migrations:
  image:
    repository: reportportal/migrations
    tag: 5.15.0
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 100m
      memory: 128Mi
  pullPolicy: Always
  affinity: {}
  podLabels: {}
  podAnnotations: {}
  securityContext: {}
  ## @param migrations.nodeSelector define which Nodes the Pods are scheduled on.
  ## You can choose compute classes for GKE Autopilot Pods https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-compute-classes
  ## Use cloud.google.com/compute-class: COMPUTE_CLASS for specific GKE Autopilot compute class.
  ## Use kubernetes.io/arch: ARCHITECTURE for specific GKE Autopilot CPU architecture.
  ##
  nodeSelector: {}
  serviceAccountName: ""
  ## @param migrations.tolerations Service-specific tolerations for the migrations job
  tolerations: []
  ## @param migrations.pdb Service-specific pod disruption budget for the migrations job
  pdb:
    create: false
    minAvailable: ""
    maxUnavailable: ""

## @section Infrastructure configuration
##
database:
  secretName: ""
  passwordKeyName: "postgresql-password"
  ## @param database.endpoint by default "{{ .Release.Name }}-postgresql.{{ .Release.Namespace }}.svc.cluster.local"
  ##
  endpoint:
  port: &dbport 5432
  user: &dbuser postgres
  dbName: &dbname reportportal
  ## @param database.endpoint.ssl configure SSL connection to the database
  ## Incoming parameters: require, disable
  ##
  ssl: disable
  password: &dbpassword rppassword
  ## @param database.connections define the number of connections to the database
  ##
  connections: &dbconnections ""

msgbroker:
  secretName: ""
  ## @param msgbroker.vhost Virtual hosts provide logical grouping and separation of resources
  ## Ref: https://www.rabbitmq.com/vhosts.html
  ##
  vhost: analyzer
  analyzerExchangeName: analyzer-default
  ## @param msgbroker.ssl configure SSL connection to the message broker
  ## Incoming parameters: true (HTTPS and AMQPS), false (HTTP and AMQP)
  ##
  ssl: false
  ## @param msgbroker.endpoint by default "{{ .Release.Name }}-rabbitmq.{{ .Release.Namespace }}.svc.cluster.local"
  ##
  endpoint:
  port: &msgbrokerPort 5672
  user: &msgbrokerUser rabbitmq
  apiport: &msgbrokerApiPort 15672
  apiuser: *msgbrokerUser
  password: &msgbrokerPass rabbitmqpassword

searchengine:
  ## @param searchengine.secretName Kubernetes secret containing search engine credentials
  ## When set, credentials are read from the secret instead of inline values
  ##
  secretName: ""
  ## @param searchengine.userKeyName Key name for username in the secret
  ##
  userKeyName: "username"
  ## @param searchengine.passwordKeyName Key name for password in the secret
  ##
  passwordKeyName: "password"
  ## @param searchengine.endpoint URL without protocol and port. By default, opensearch-cluster-master.{{ .Release.Namespace }}.svc.cluster.local
  ##
  endpoint:
  ## @param searchengine.ssl configure SSL connection to the search engine
  ## Incoming parameters: true (HTTPS), false (HTTP)
  ##
  ssl: false
  port: &searchenginePort 9200
  ## @param searchengine.user Inline username (used when secretName is not set)
  ##
  user:
  ## @param searchengine.password Inline password (used when secretName is not set)
  ##
  password:

## @section Storage Configuration
##
## ReportPortal supports three storage types: minio, s3, and filesystem
## Choose the storage type that best fits your environment and requirements
##
## Quick Start Presets:
##   - For local development: use "minio" (default)
##   - For production with cloud storage: use "s3"
##   - For production with shared filesystem: use "filesystem"
##
## Storage Type Comparison:
##   - minio: Self-hosted object storage (good for development/testing)
##   - s3: Cloud object storage (good for production, supports IAM roles)
##   - filesystem: Shared filesystem storage (good for production with existing storage)
##
storage:
  ## @param storage.type Storage type to use for ReportPortal data
  ## Options: minio, s3, filesystem
  ## Default: minio (recommended for development)
  ##
  type: minio

  ## @param storage.secretName Kubernetes secret containing storage credentials
  ## Leave empty to use inline credentials below
  ## Recommended for production: create a secret and reference it here
  ##
  secretName: ""

  ## @param storage.accesskeyName and @param storage.secretkeyName
  ## Secret key names when using storage.secretName
  ## These map to the keys in your Kubernetes secret
  ##
  accesskeyName: "access-key"
  secretkeyName: "secret-key"

  ## @param storage.accesskey and @param storage.secretkey
  ## Inline storage credentials (not recommended for production)
  ## For S3 with IAM roles, leave these empty
  ##
  accesskey: &storageAccessKey rpuser
  secretkey: &storageSecretKey miniopassword

  ## @param storage.endpoint Storage service endpoint
  ## For MinIO: leave empty to use internal service
  ## For S3: leave empty to use AWS default endpoints
  ## For custom S3-compatible: specify endpoint URL (without protocol/port)
  ##
  endpoint:

  ## @param storage.ssl Enable SSL/TLS for storage connections
  ## true = HTTPS, false = HTTP
  ##
  ssl: false

  ## @param storage.port Storage service port
  ## Default: 9000 (MinIO standard port)
  ##
  port: 9000

  ## @param storage.region AWS region for S3 storage
  ## Required for S3 storage type
  ## Examples: us-east-1, eu-west-1, ap-southeast-1
  ##
  region: ""

  ## @param storage.bucket Bucket configuration for object storage (minio/s3)
  ##
  bucket:
    ## @param storage.bucket.type Bucket organization strategy
    ## Options: single, multi
    ##   single: One bucket for all data with subdirectories (recommended for production)
    ##   multi: Separate bucket for each project (not recommended - creates many buckets)
    ##
    ## IMPORTANT: Multi-bucket strategy is NOT recommended for production S3 deployments
    ## because ReportPortal will create a separate S3 bucket for each project in the portal
    ## Use single bucket strategy which creates one bucket with subdirectories for better management.
    ##
    type: multi

    ## @param storage.bucket.bucketDefaultName Default bucket name
    ## For single bucket mode: this is the main bucket name
    ## For multi bucket mode: this is the plugins bucket name
    ##
    bucketDefaultName: "rp-bucket"

    ## @param storage.bucket.bucketMultiPrefix Prefix for project buckets (multi mode only)
    ## Project buckets will be named: {prefix}{project-id}{postfix}
    ##
    bucketMultiPrefix: "prj-"

    ## @param storage.bucket.bucketMultiPostfix Suffix for project buckets (multi mode only)
    ##
    bucketMultiPostfix: ""

    ## @param storage.bucket.bucketMultiSaltName Salt storage location (multi mode only)
    ##
    bucketMultiSaltName: "keystore"

  ## @param storage.volume Filesystem storage configuration (when type=filesystem)
  ##
  volume:
    ## @param storage.volume.capacity Storage size for filesystem storage
    ## Examples: 5Gi, 10Gi, 100Gi
    ##
    capacity: 5Gi

    ## @param storage.volume.storageClassName Kubernetes storage class name
    ## Examples: standard, standard-rwx, fast-ssd
    ## For GKE with Filestore: use "standard-rwx"
    ##
    storageClassName: "standard"

    ## @param storage.volume.annotations Annotations for the PersistentVolumeClaim
    ##
    annotations: {}

    ## @param storage.volume.volumeConfig PersistentVolume configuration
    ## Only needed for custom volume types (hostPath, local, CSI)
    ## For cloud providers, leave empty to use dynamic provisioning
    ##
    volumeConfig:
      ## @param storage.volume.volumeConfig.type Volume type for custom provisioning
      ## Options: hostPath, local, csi
      ## Leave empty to use dynamic provisioning (recommended for cloud)
      ##
      type: ""

      ## @param storage.volume.volumeConfig.hostPath HostPath volume configuration
      ##
      hostPath: {}

      ## @param storage.volume.volumeConfig.local Local volume configuration
      ##
      local:
        nodeSelectorNames: []

      ## @param storage.volume.volumeConfig.csi CSI volume configuration
      ##
      csi:
        ## @param storage.volume.volumeConfig.csi.driver CSI driver name
        ##
        driver: ""

        ## @param storage.volume.volumeConfig.csi.volumeHandle CSI volume handle
        ##
        volumeHandle: ""

        ## @param storage.volume.volumeConfig.csi.fsType Filesystem type
        ## Examples: ext4, xfs, nfs
        ##
        fsType: ""

        ## @param storage.volume.volumeConfig.csi.readOnly Read-only volume
        ## true/false
        ##
        readOnly: ""

        ## @param storage.volume.volumeConfig.csi.volumeAttributes Additional CSI attributes
        ##
        volumeAttributes: {}


## @section Ingress configuration
##
## If you have installed ingress controller and want to expose application - set @param ingress.enable to `true`
## @param ingress.hosts set variable this you domain names list (FQDN) if you have some domain name and want to use it in ingress rules.
## @param ingress.hosts is required if you want to use Google Managed Certificate.
##
## @param ingress.class set to `nginx` if you have nginx ingress controller.
## @param ingress.class set to `gce` if you want to use GCE ingress controller.
## @param ingress.class set to `alb` if you want to use AWS Load Balancer Controller.
## @param ingress.class set to any other ingress controller name if you want to use it.
## @param ingress.path is an Application path as a prefix, should start from '/' and be without trailing '/'. Use to deploy ReportPortal to path, E.G. 'https://example.com/reportportal/'
## @param ingress.annotations.custom if you use other ingress controller set your annotations here.
##
## @param ingress.tls.certificates specify a list of predefined secret names for TLS certificates present in the same namespace
## certificates:
##   - secretName: reportportal.k8.com-tls
##     hosts:
##       - reportportal.k8.com
##
## @param ingress.tls.certificate.privateKey provide a base64-encoded private key for TLS.
## @param ingress.tls.certificate.certificate provide a base64-encoded certificate for TLS.
## @param ingress.tls.certificate.gcpManaged set to `true` if you want to use Google Managed Certificate instead of providing your own certificate.
##

ingress:
  enable: true
  ## @param ingress.hosts can be a list or a single string
  ##
  hosts: null
  path: ""
  class: nginx
  ## @param ingress.annotations Ingress annotations
  ## Add annotations based on your ingress controller
  ##
  ## Example for Nginx Ingress Controller:
  ##   nginx.ingress.kubernetes.io/ssl-redirect: "false"
  ##   nginx.ingress.kubernetes.io/proxy-body-size: 128m
  ##   nginx.ingress.kubernetes.io/proxy-buffer-size: 512k
  ##   nginx.ingress.kubernetes.io/proxy-buffers-number: "4"
  ##   nginx.ingress.kubernetes.io/proxy-busy-buffers-size: 512k
  ##   nginx.ingress.kubernetes.io/proxy-connect-timeout: "8000"
  ##   nginx.ingress.kubernetes.io/proxy-read-timeout: "4000"
  ##   nginx.ingress.kubernetes.io/proxy-send-timeout: "4000"
  ##
  ## Example for AWS ALB Ingress Controller:
  ##   kubernetes.io/ingress.class: alb
  ##   alb.ingress.kubernetes.io/load-balancer-name: "reportportal-alb"
  ##   alb.ingress.kubernetes.io/scheme: "internet-facing"
  ##   alb.ingress.kubernetes.io/target-type: "ip"
  ##   alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS": 443}]'
  ##   alb.ingress.kubernetes.io/ssl-redirect: "443"
  ##   alb.ingress.kubernetes.io/group.name: "reportportal"
  ##   alb.ingress.kubernetes.io/group.order: "1"
  ##   alb.ingress.kubernetes.io/healthcheck-path: "/"
  ##   alb.ingress.kubernetes.io/healthcheck-port: "traffic-port"
  ##   alb.ingress.kubernetes.io/healthcheck-protocol: "HTTP"
  ##   alb.ingress.kubernetes.io/success-codes: "200"
  ##   alb.ingress.kubernetes.io/healthy-threshold-count: "2"
  ##   alb.ingress.kubernetes.io/unhealthy-threshold-count: "2"
  ##   alb.ingress.kubernetes.io/security-groups: "sg-xxxxxxxxx"
  ##   alb.ingress.kubernetes.io/subnets: "subnet-xxxxxxxxx,subnet-yyyyyyyyy"
  ##   alb.ingress.kubernetes.io/certificate-arn: "arn:aws:acm:region:account:certificate/certificate-id"
  ##   alb.ingress.kubernetes.io/load-balancer-attributes: "idle_timeout.timeout_seconds=60"
  ##   alb.ingress.kubernetes.io/target-group-attributes: "stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=86400"
  ##
  ## Example for GCE Ingress Controller:
  ##   kubernetes.io/ingress.class: gce
  ##
  annotations: {}
  tls:
    certificates: null
    certificate:
      gcpManaged: false
      privateKey: null
      certificate: null

## @section Gateway API Configuration
## Gateway API is the modern replacement for Ingress, recommended by Kubernetes.
## Note: Ingress NGINX is being retired in March 2026.
## See: https://kubernetes.io/blog/2025/11/11/ingress-nginx-retirement/
##
## @param gatewayAPI.enable Enable Gateway API resources (HTTPRoute)
## @param gatewayAPI.hostnames Hostnames for the HTTPRoute (can be a list or single string)
## @param gatewayAPI.path Base path for all routes (default: "")
##

gatewayAPI:
  enable: false
  ## @param gatewayAPI.hostnames Hostnames to match for routing
  ## Can be a single hostname or a list
  ## Example:
  ##   hostnames: reportportal.example.com
  ## or:
  ##   hostnames:
  ##     - reportportal.example.com
  ##     - rp.example.com
  ##
  hostnames: null
  ## @param gatewayAPI.path Base path prefix for all routes
  ##
  path: ""
  ## @param gatewayAPI.parentRefs Custom parent references (advanced)
  ## If not set, gatewayRef will be used to construct parentRefs
  ##
  parentRefs: null
  ## @param gatewayAPI.gatewayRef Reference to an existing Gateway
  ## Used when parentRefs is not set
  ##
  gatewayRef:
    ## @param gatewayAPI.gatewayRef.name Name of the Gateway to attach routes to
    ##
    name: ""
    ## @param gatewayAPI.gatewayRef.namespace Namespace of the Gateway (optional, defaults to same namespace)
    ##
    namespace: ""
    ## @param gatewayAPI.gatewayRef.sectionName Specific listener on the Gateway (optional)
    ##
    sectionName: ""
  ## @param gatewayAPI.httpRoute HTTPRoute configuration
  ##
  httpRoute:
    ## @param gatewayAPI.httpRoute.annotations Annotations for the HTTPRoute
    ##
    annotations: {}
    ## @param gatewayAPI.httpRoute.backendRefs Backend reference options
    ##
    backendRefs:
      weight: null
    ## @param gatewayAPI.httpRoute.additionalRules Additional routing rules
    ##
    additionalRules: []
  ## @param gatewayAPI.gateway Gateway resource configuration
  ## Set gateway.create to true to create a new Gateway resource
  ## Otherwise, reference an existing Gateway using gatewayRef
  ##
  gateway:
    ## @param gatewayAPI.gateway.create Create a Gateway resource
    ##
    create: false
    ## @param gatewayAPI.gateway.name Gateway name (defaults to <fullname>-gateway)
    ##
    name: ""
    ## @param gatewayAPI.gateway.className GatewayClass name
    ## Common options: istio, cilium, nginx, envoy-gateway, gke-l7-rilb, gke-l7-global-external-managed
    ##
    className: ""
    ## @param gatewayAPI.gateway.annotations Gateway annotations
    ##
    annotations: {}
    ## @param gatewayAPI.gateway.addresses Gateway addresses (optional)
    ##
    addresses: []
    ## @param gatewayAPI.gateway.listeners Custom listeners (optional, overrides defaults)
    ## If not specified, HTTP (and optionally HTTPS) listeners will be created
    ##
    listeners: null
    ## @param gatewayAPI.gateway.tls TLS configuration for the Gateway
    ##
    tls:
      ## @param gatewayAPI.gateway.tls.enable Enable HTTPS listener
      ##
      enable: false
      ## @param gatewayAPI.gateway.tls.mode TLS termination mode (Terminate or Passthrough)
      ##
      mode: Terminate
      ## @param gatewayAPI.gateway.tls.secretName TLS secret name
      ##
      secretName: ""
      ## @param gatewayAPI.gateway.tls.certificateRefs Custom certificate references
      ##
      certificateRefs: null

## @section Additional configuration
##
## Role Based Access
## ref: https://kubernetes.io/docs/admin/authorization/rbac/
##
rbac:
  ## @param rbac is required for service-index in order to collect status/info over all services
  ##
  create: true
  ## @param rbac.rules define the rules for ReportPortal
  ##
  rules: []
    # - apiGroups: ["", "batch"]
    #   resources: ["pods","services", "jobs"]
    #   verbs: ["get", "list", "watch"]

## @param k8sWaitFor External k8s-wait-for Helm Chart as dependency
##
k8sWaitFor:
  image:
    repository: reportportal/k8s-wait-for
    tag: latest

## @param kubectl image for templates/hooks/pre-upgrade-cleanup.yaml
##
kubectl:
  image:
    repository: bitnamisecure/kubectl
    tag: latest

## Networking between pods
## Set @param k8s.networking.ssl to `true` if SSL enabled between pods inside Kubernetes cluster
##
k8s:
  networking:
    ssl: false

## @param hooks Helm 3+ hooks toggles
hooks:
  enabled: true
  preUpgrade:
    enabled: true
    resources:
      requests:
        cpu: 50m
        memory: 64Mi
      limits:
        cpu: 100m
        memory: 128Mi
    ## @param hooks.preUpgrade.tolerations Service-specific tolerations for the pre-upgrade cleanup job
    ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
    ##
    tolerations: []
  test:
    enabled: true
    resources:
      requests:
        cpu: 50m
        memory: 64Mi
      limits:
        cpu: 100m
        memory: 128Mi
    ## @param hooks.test.tolerations Service-specific tolerations for the readiness test pod
    ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
    ##
    tolerations: []
  image:
    repository: curlimages/curl
    tag: latest

## @param resourceQuota Configure resource quotas for the namespace
##
resourceQuota:
  enabled: false
  cpu: "6"
  memory: "8Gi"
  pods: "20"
  services: "12"
  persistentvolumeclaims: "5"

## @section External dependencies installation configuration
##
## @param postgresql External PostgreSQL Helm Chart as dependency
##
postgresql:
  ## set to `false` if using a Cloud/On-Premise managed database
  ##
  install: true
  image:
    repository: bitnamilegacy/postgresql
    tag: 17.5.0-debian-12-r20
  auth:
    postgresPassword: *dbpassword
    username: *dbuser
    password: *dbpassword
    database: *dbname
  primary:
    service:
      ports:
        postgresql: *dbport

## @param rabbitmq External RabbitMQ Helm Chart as dependency
## Set @param rabbitmq.install to `false` if using a Cloud/On-Premise managed RabbitMQ
##
rabbitmq:
  install: true
  image:
    repository: bitnamilegacy/rabbitmq
    tag: 4.1.2-debian-12-r1
  auth:
    username: *msgbrokerUser
    password: *msgbrokerPass
  containerPorts:
    amqp: *msgbrokerPort
    manager: *msgbrokerApiPort
  ## @param rabbitmq.extraPlugins define additional RabbitMQ plugins to be enabled
  ## Required for the ReportPortal to work
  ##
  extraPlugins: >
    rabbitmq_auth_backend_ldap
    rabbitmq_consistent_hash_exchange
    rabbitmq_shovel
    rabbitmq_shovel_management
  ## @param rabbitmq.extraConfiguration additional RabbitMQ configuration
  ## @param rabbitmq.extraConfiguration.max_message_size increases the maximum allowed size for a single message
  ## 128 MB (134217728 bytes) recommended for ReportPortal
  ##
  extraConfiguration: |-
    max_message_size = 134217728
  ingress:
    tls: []

## @param opensearch External OpenSearch Helm Chart as dependency
## Set @param opensearch.install to `false` if using a Cloud/On-Premise managed OpenSearch
##
opensearch:
  install: true
  image:
    repository: opensearchproject/opensearch
    tag: 2.19.4
  ## @param opensearch.singleNode If "true", replicas will be forced from 3 to 1
  ##
  singleNode: true
  ## @param opensearch.httpPort Port for OpenSearch endpoint
  ##
  httpPort: *searchenginePort
  startupProbe:
    initialDelaySeconds: 30
  extraEnvs:
    - name: DISABLE_INSTALL_DEMO_CONFIG
      value: "true"
    - name: DISABLE_SECURITY_PLUGIN
      value: "true"

## @param minio External MinIO Helm Chart
## Set @param minio.install to `false` if using a Cloud/On-Premise managed binary storage
##
minio:
  install: true
  image:
    repository: bitnamilegacy/minio
    tag: 2025.7.23-debian-12-r0
  auth:
    rootUser: *storageAccessKey
    rootPassword: *storageSecretKey
  persistence:
    annotations:
      "helm.sh/resource-policy": "keep"
  console:
    enabled: false
